{{> fragment.header.hbs }}

import type { JudoIdentifiable } from '@judo/data-api-common';
import { JudoAxiosService } from './JudoAxiosService';
import type { {{ joinedTokensForApiImport relation }} } from '../data-api';
import type { {{ serviceRelationName relation }} } from '../data-service';

/**
* Relation Service Implementation for {{ classDataName (getRelationOwnerAsClassType relation) "" }}.{{ relation.name }}
*/
export class {{ serviceRelationName relation }}Impl extends JudoAxiosService implements {{ serviceRelationName relation }} {
{{# if relation.isListable }}
    {{# if relation.isCollection }}
        /**
         * From: relation.isListable, relation.isCollection
         * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 401, 403.
         */
        async list(owner?: JudoIdentifiable<any>, queryCustomizer?: {{ classDataName relation.target "QueryCustomizer" }}): Promise<Array<{{ classDataName relation.target "Stored" }}>> {
            const path = '{{ restPath (getRelationOwnerAsClassType relation) "/"  relation.name "/~list" }}';
            const response = await this.axios.post(this.getPathForActor(path), queryCustomizer ?? {}, owner ? {
                headers: {
                    'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                },
            } : undefined);

            return response.data;
        }
    {{/ if }}
{{/ if }}

{{# if relation.isRefreshable }}
    {{# if relation.isAccess }}
        {{# unless relation.isCollection }}
            /**
             * From: relation.isAccess, !relation.isCollection
             * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 401, 403.
             */
            async refreshFor{{ firstToUpper relation.name }}(queryCustomizer?: {{ classDataName relation.target "QueryCustomizer" }}): Promise<{{ classDataName relation.target "Stored" }}> {
                const path = '{{ restPath (getRelationOwnerAsClassType relation) "/" relation.name "/~get" }}';
                const response = await this.axios.post(this.getPathForActor(path), queryCustomizer ?? {});

                return response.data;
            }
        {{/ unless }}
    {{/ if }}

    /**
     * From: relation.isRefreshable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 401, 403.
     */
    async refresh(owner?: JudoIdentifiable<any>, queryCustomizer?: {{ classDataName relation.target "QueryCustomizer" }}): Promise<{{ classDataName relation.target "Stored" }}> {
        const path = '{{ restPath relation.target "/~get" }}';
        const response = await this.axios.post(this.getPathForActor(path), queryCustomizer ?? {}, owner ? {
            headers: {
                'X-Judo-SignedIdentifier': owner.__signedIdentifier,
            },
        } : undefined);

        return response.data;
    }
{{/ if }}

{{# if relation.isRangeable }}
    /**
     * From: relation.isRangeable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 401, 403.
     */
    async getRangeFor{{ firstToUpper relation.name }}({{# unless relation.isAccess }}owner: JudoIdentifiable<{{ classDataName (getRelationOwnerAsClassType relation) "" }}> | {{ classDataName (getRelationOwnerAsClassType relation) "" }}, {{/ unless }}queryCustomizer?:{{ classDataName relation.target "QueryCustomizer" }}): Promise<Array<{{ classDataName relation.target "Stored" }}>> {
        const path = '{{ restPath (getRelationOwnerAsClassType relation) "/" relation.name "/~range" }}';
        const response = await this.axios.post(this.getPathForActor(path), {
            {{# unless relation.isAccess }}owner: owner ?? {},{{/ unless }}
            queryCustomizer: queryCustomizer ?? {}
        });

        return response.data;
    }
{{/ if }}

{{# if relation.target.isTemplateable }}
    /**
     * From: relation.target.isTemplateable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 401, 403.
     */
    async getTemplate(): Promise<{{ classDataName relation.target "" }}> {
        const path = '{{ restPath relation.target "/~template" }}';
        const response = await this.axios.get(this.getPathForActor(path));

        return response.data;
    }
{{/ if }}

{{# if relation.isCreatable }}
    /**
     * From: relation.isCreatable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async create({{# unless relation.isAccess }}owner: JudoIdentifiable<{{ classDataName (getRelationOwnerAsClassType relation) "" }}>, {{/ unless }}target: {{ classDataName relation.target "" }}): Promise<{{ classDataName relation.target "Stored" }}> {
        {{# unless relation.isAccess }}
            const path = '{{ restPath (getRelationOwnerAsClassType relation) "/~update/"  relation.name "/~create" }}';
        {{ else }}
            const path = '{{ restPath (getRelationOwnerAsClassType relation) "/" relation.name "/~create" }}';
        {{/ unless }}
        const response = await this.axios.post(this.getPathForActor(path), target{{# unless relation.isAccess }}, {
            headers: {
                'X-Judo-SignedIdentifier': owner.__signedIdentifier,
            },
        } {{/ unless }});

        return response.data;
    }
{{/ if }}

{{# if relation.isDeletable }}
    /**
     * From: relation.isDeletable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async delete(target: JudoIdentifiable<{{ classDataName relation.target "" }}>): Promise<void> {
        const path = '{{ restPath relation.target "/~delete" }}';
        await this.axios.post(this.getPathForActor(path), undefined, {
            headers: {
                'X-Judo-SignedIdentifier': target.__signedIdentifier,
            },
        });
    }
{{/ if }}

{{# if relation.isUpdatable }}
    /**
     * From: relation.isUpdatable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async update(target: Partial<{{ classDataName relation.target "Stored" }}>): Promise<{{ classDataName relation.target "Stored" }}> {
        const path = '{{ restPath relation.target "/~update" }}';
        const response = await this.axios.post(this.getPathForActor(path), target, {
            headers: {
                'X-Judo-SignedIdentifier': target.__signedIdentifier,
            },
        });

        return response.data;
    }
{{/ if }}

{{# if relation.isSetable }}
    /**
     * From: relation.isSetable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async set{{ firstToUpper relation.name }}({{# unless relation.isAccess }}owner: JudoIdentifiable<{{ classDataName (getRelationOwnerAsClassType relation) "" }}>, {{/ unless }}selected:{{# if relation.isCollection }}Array<{{/ if }}JudoIdentifiable<{{ classDataName relation.target "" }}>{{# if relation.isCollection }}>{{/ if }}): Promise<void> {
        const path = '{{ restPath (getRelationOwnerAsClassType relation) "/~update/" relation.name "/~set" }}';
        await this.axios.post(this.getPathForActor(path), selected{{# unless relation.isAccess }}, {
            headers: {
                'X-Judo-SignedIdentifier': owner.__signedIdentifier!,
            },
        } {{/ unless }});
    }
{{/ if }}

{{# if relation.isUnsetable }}
    /**
     * From: relation.isUnsetable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async unset{{ firstToUpper relation.name }}({{# unless relation.isAccess }}owner: JudoIdentifiable<{{ classDataName (getRelationOwnerAsClassType relation) "" }}>, {{/ unless }}): Promise<void> {
        const path = '{{ restPath (getRelationOwnerAsClassType relation) "/~update/" relation.name "/~unset" }}';
        await this.axios.post(this.getPathForActor(path), undefined{{# unless relation.isAccess }}, {
            headers: {
                'X-Judo-SignedIdentifier': owner.__signedIdentifier!,
            },
        } {{/ unless }});
    }
{{/ if }}

{{# if relation.isAddable }}
    /**
     * From: relation.isAddable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async add{{ firstToUpper relation.name }}({{# unless relation.isAccess }}owner: JudoIdentifiable<{{ classDataName (getRelationOwnerAsClassType relation) "" }}>, {{/ unless }}selected: Array<JudoIdentifiable<{{ classDataName relation.target "" }}>>): Promise<void> {
        const path = '{{ restPath (getRelationOwnerAsClassType relation) "/~update/" relation.name "/~add" }}';
        await this.axios.post(this.getPathForActor(path), selected{{# unless relation.isAccess }}, {
            headers: {
                'X-Judo-SignedIdentifier': owner.__signedIdentifier!,
            },
        } {{/ unless }});
    }
{{/ if }}

{{# if relation.isRemovable }}
    /**
     * From: relation.isRemovable
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async remove{{ firstToUpper relation.name }}({{# unless relation.isAccess }}owner: JudoIdentifiable<{{ classDataName (getRelationOwnerAsClassType relation) "" }}>, {{/ unless }}selected: Array<JudoIdentifiable<{{ classDataName relation.target "" }}>>): Promise<void> {
        const path = '{{ restPath (getRelationOwnerAsClassType relation) "/~update/" relation.name "/~remove" }}';
        await this.axios.post(this.getPathForActor(path), selected{{# unless relation.isAccess }}, {
            headers: {
                'X-Judo-SignedIdentifier': owner.__signedIdentifier!,
            },
        } {{/ unless }});
    }
{{/ if }}

{{# each relation.target.relations as | targetRelation | }}
    {{# if targetRelation.isListable }}
        {{# if targetRelation.isCollection }}
            async list{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target "" }}>, queryCustomizer?: {{ classDataName targetRelation.target "QueryCustomizer" }}): Promise<Array<{{ classDataName targetRelation.target "Stored" }}>> {
                const path = '{{ restPath relation.target "/"  targetRelation.name "/~list" }}';
                const response = await this.axios.post(this.getPathForActor(path), queryCustomizer ?? {}, {
                    headers: {
                        'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                    },
                });

                return response.data;
            }
        {{ else }}
            async get{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target "" }}>, queryCustomizer?: {{ classDataName targetRelation.target "QueryCustomizer" }}): Promise<{{ classDataName targetRelation.target "Stored" }}> {
                const path = '{{ restPath relation.target "/" targetRelation.name "/~get" }}';
                const response = await this.axios.post(this.getPathForActor(path), queryCustomizer ?? {}, {
                    headers: {
                        'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                    },
                });

                return response.data;
            }
        {{/ if }}
    {{/ if }}

    {{# if targetRelation.isRangeable }}
        {{# neq relation.name targetRelation.name }}
        /**
         * Form: targetRelation.isRangeable
         * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 401, 403.
         */
        async getRangeFor{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target "" }}> | {{ classDataName relation.target "" }}, queryCustomizer?: {{ classDataName targetRelation.target "QueryCustomizer" }}): Promise<Array<{{ classDataName targetRelation.target "Stored" }}>> {
            const path = '{{ restPath relation.target "/" targetRelation.name "/~range" }}';
            const response = await this.axios.post(this.getPathForActor(path), {
                owner: owner,
                queryCustomizer: queryCustomizer ?? {}
            });

            return response.data;
        }
        {{/ neq }}
    {{/ if }}

    {{# if targetRelation.target.isTemplateable }}
        async getTemplateFor{{ firstToUpper targetRelation.name }}(): Promise<{{ classDataName targetRelation.target '' }}> {
            const path = '{{ restPath targetRelation.target "/~template" }}';
            const response = await this.axios.get(this.getPathForActor(path));

            return response.data;
        }
    {{/ if }}

    {{# if targetRelation.isCreatable }}
        async create{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target }}>, target: {{ classDataName targetRelation.target }}): Promise<{{ classDataName targetRelation.target "Stored" }}> {
            const path = '{{ restPath relation.target "/~update/"  targetRelation.name "/~create" }}';
            const response = await this.axios.post(this.getPathForActor(path), target, {
                headers: {
                    'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                },
            });

            return response.data;
        }
    {{/ if }}

    {{# if targetRelation.isDeletable }}
        async delete{{ firstToUpper targetRelation.name }}(target: JudoIdentifiable<{{ classDataName targetRelation.target }}>): Promise<void> {
            const path = '{{ restPath targetRelation.target "/~delete" }}';
            await this.axios.post(this.getPathForActor(path), undefined, {
                headers: {
                    'X-Judo-SignedIdentifier': target.__signedIdentifier,
                },
            });
        }
    {{/ if }}

    {{# if targetRelation.isUpdatable }}
        async update{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target }}>, target: Partial<{{ classDataName targetRelation.target "Stored" }}>): Promise<{{ classDataName targetRelation.target "Stored" }}> {
            const path = '{{ restPath relation.target "/~update/"  targetRelation.name "/~update" }}';
            const response = await this.axios.post(this.getPathForActor(path), target, {
                headers: {
                    'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                },
            });

            return response.data;
        }
    {{/ if }}

    {{# if targetRelation.isSetable }}
        {{# neq relation.name targetRelation.name }}
        /**
         * From: targetRelation.isSetable
         * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
         */
        async set{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target "" }}>, selected: {{# if targetRelation.isCollection }}Array<{{/ if }}JudoIdentifiable<{{ classDataName targetRelation.target "" }}>{{# if targetRelation.isCollection}}>{{/ if }}): Promise<void> {
            const path = '{{ restPath relation.target "/~update/"  targetRelation.name "/~set" }}';
            await this.axios.post(this.getPathForActor(path), selected, {
                headers: {
                    'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                },
            });
        }
        {{/ neq }}
    {{/ if }}

    {{# if targetRelation.isUnsetable }}
        {{# neq relation.name targetRelation.name }}
        /**
         * From: targetRelation.isUnsetable
         * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
         */
        async unset{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target "" }}>): Promise<void> {
            const path = '{{ restPath relation.target "/~update/"  targetRelation.name "/~unset" }}';
            await this.axios.post(this.getPathForActor(path), undefined, {
                headers: {
                    'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                },
            });
        }
        {{/ neq }}
    {{/ if }}

    {{# if targetRelation.isAddable }}
        {{# neq relation.name targetRelation.name }}
        /**
         * From: targetRelation.isAddable
         * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
         */
        async add{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target "" }}>, selected: Array<JudoIdentifiable<{{ classDataName targetRelation.target "" }}>>): Promise<void> {
            const path = '{{ restPath relation.target "/~update/"  targetRelation.name "/~add" }}';
            await this.axios.post(this.getPathForActor(path), selected, {
                headers: {
                    'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                },
            });
        }
        {{/ neq }}
    {{/ if }}

    {{# if targetRelation.isRemovable }}
        {{# neq relation.name targetRelation.name }}
        /**
         * From: targetRelation.isRemovable
         * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
         */
        async remove{{ firstToUpper targetRelation.name }}(owner: JudoIdentifiable<{{ classDataName relation.target "" }}>, selected: Array<JudoIdentifiable<{{ classDataName targetRelation.target "" }}>>): Promise<void> {
            const path = '{{ restPath relation.target "/~update/"  targetRelation.name "/~remove" }}';
            await this.axios.post(this.getPathForActor(path), selected, {
                headers: {
                    'X-Judo-SignedIdentifier': owner.__signedIdentifier,
                },
            });
        }
        {{/ neq }}
    {{/ if }}
{{/ each }}

{{# each relation.target.operations as | operation | }}
    /**
     * From: relation.target.operations
     * @throws {AxiosError}{{# if (hasFaults operation) }}With data containing {@link{{ faultContainerName operation }} } for business related errors (status code is 422).{{/ if }}
     * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 400, 401, 403.
     */
    async {{ operation.name }}({{# unless operation.isStatic }}owner: JudoIdentifiable<{{ classDataName relation.target "" }}>{{/ unless }}{{# if operation.input }}{{# unless operation.isStatic }}, {{/ unless }}target:{{ classDataName operation.input.target  "" }}{{/ if }}): Promise<{{# if operation.output }}{{ classDataName operation.output.target "Stored" }}{{ else }}void{{/ if }}> {
        const path = '{{ operationRestPath relation.target operation '' }}';
        const response = await this.axios.post(this.getPathForActor(path){{# if operation.input }}, target{{ else }}, undefined{{/ if }}{{# unless operation.isStatic }}, {
            headers: {
                'X-Judo-SignedIdentifier': owner.__signedIdentifier!,
            },
        } {{/ unless }});

        {{# if operation.output }}
            return response.data;
        {{/ if }}
    }

    {{# if operation.input }}
        {{# if operation.input.target.isTemplateable }}
            async getTemplateFor{{ firstToUpper operation.name }}(): Promise<{{ classDataName operation.input.target '' }}> {
                const path = '{{ restPath operation.input.target "/~template" }}';
                const response = await this.axios.get(this.getPathForActor(path));

                return response.data;
            }
        {{/ if }}
    {{/ if }}

    {{# if operation.isInputRangeable }}
        {{# neq relation.name targetRelation.name }}
        /**
         * From: relation.target.operations operation.isInputRangeable
         * @throws {AxiosError} With data containing {@link Array<FeedbackItem>} for status codes: 401, 403.
         */
        async getRangeFor{{ firstToUpper operation.name }}({{# unless operation.isStatic }}owner: JudoIdentifiable<{{ classDataName relation.target "" }}> | {{ classDataName relation.target "" }}, {{/ unless }}queryCustomizer?:{{ classDataName operation.input.target "QueryCustomizer" }}): Promise<Array<{{ classDataName operation.input.target "Stored" }}>> {
            const path = '{{ operationRestPath relation.target operation '/~range' }}';
            const response = await this.axios.post(this.getPathForActor(path), {
                {{# unless operation.isStatic }}owner: owner ?? {},{{/ unless }}
                queryCustomizer: queryCustomizer ?? {}
            });

            return response.data;
        }
        {{/ neq }}
    {{/ if }}
{{/ each }}
}
